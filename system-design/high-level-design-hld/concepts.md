# System Design Core Topics

System design interviews aren't about memorizing complex case studies.

It's more about mastering the core concepts.

Sure, it's good to understand complex systems like distributed databases or microservices. But these aren't always the focus of interviews.

Instead, focus on building a strong foundation first.

No matter your programming language, start by understanding the basics of how systems are designed.

𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐊𝐞𝐲 𝐂𝐨𝐧𝐜𝐞𝐩𝐭𝐬

1. Scalability:

https://lnkd.in/gpge_z76

2. Latency vs Throughput:

https://lnkd.in/g_amhAtN

3. CAP Theorem:

https://lnkd.in/g3hmVamx

4. ACID Transactions:

https://lnkd.in/gMe2JqaF

5. Rate Limiting:

https://lnkd.in/gWsTDR3m

6. API Design:

https://lnkd.in/ghYzrr8q

7. Strong vs Eventual Consistency:

https://lnkd.in/gJ-uXQXZ

8. Distributed Tracing:

https://lnkd.in/d6r5RdXG

9. Synchronous vs. asynchronous communications:

https://lnkd.in/gC3F2nvr

10. Batch Processing vs Stream Processing:

https://lnkd.in/g4_MzM4s

𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐁𝐮𝐢𝐥𝐝𝐢𝐧𝐠 𝐁𝐥𝐨𝐜𝐤𝐬

1. Databases:

https://lnkd.in/gti8gjpz

2. Horizontal vs Vertical Scaling:

https://lnkd.in/gAH2e9du

3. Caching:

https://lnkd.in/gC9piQbJ

4. Distributed Caching:

https://lnkd.in/g7WKydNg

5. Load Balancing:

https://lnkd.in/gQaa8sXK

6. SQL vs NoSQL:

https://lnkd.in/g3WC_yxn

7. Database Scaling:

https://lnkd.in/gAXpSyWQ

8. Data Replication:

https://lnkd.in/gVAJxTpS

9. Data Redundancy:

https://lnkd.in/gNN7TF7n

10. Database Sharding:

https://lnkd.in/gMqqc6x9

11. Database Index's:

https://lnkd.in/gCeshYVt

13. WebSocket:

https://lnkd.in/g76Gv2KQ

14. API Gateway:

https://lnkd.in/gnsJGJaM

15. Message Queues:

https://lnkd.in/gTzY6uk8

𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐚𝐥 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬

1. Event-Driven Architecture:

https://lnkd.in/dp8CPvey

2. Client-Server Architecture:

https://lnkd.in/dAARQYzq

3. Serverless Architecture:

https://lnkd.in/gQNAXKkb

4. Microservices Architecture:

https://lnkd.in/gFXUrz_T

𝐌𝐚𝐜𝐡𝐢𝐧𝐞 𝐂𝐨𝐝𝐢𝐧𝐠 𝐑𝐨𝐮𝐧𝐝 𝐚𝐧𝐝 𝐋𝐨𝐰 𝐋𝐞𝐯𝐞𝐥 𝐃𝐞𝐬𝐢𝐠𝐧 𝐏𝐫𝐨𝐛𝐥𝐞𝐦𝐬

1. Design a Parking Lot:

https://lnkd.in/dQaAuFd2

2. Design Chess Validator:

https://lnkd.in/dfAQHvN4

3. Design a Distributed Queue | Kafka:

https://lnkd.in/dQ6_B4_M

4. Design Tic-Tac-Toe:

https://lnkd.in/dFDApUBt

18th Oct 2024

---

1. Databases:

https://lnkd.in/gtGRQpQi

2. Horizontal vs Vertical Scaling:

https://lnkd.in/g7y--BPq

3. Load Balancing:

https://lnkd.in/g5htBkrB

4. SQL vs NoSQL:

https://lnkd.in/gjrzmbS5

5. Database Scaling:

https://lnkd.in/g7yRbwsF

6. Database Sharding:

https://lnkd.in/gwucPJMY

7. Message Queues:

https://lnkd.in/g-nKJZwF

18th Oct 2024 - Part 2

---

If you want to get started with system design, read these articles (not joking):

15/ Microservices Lessons From Netflix:

↳

https://lnkd.in/eZSM3CRB

14/ Idempotent API:

↳

https://lnkd.in/erMkqwq4

13/ Protocol Buffers vs JSON:

↳

https://lnkd.in/egcFxe2t

12/ Actor Model:

↳

https://lnkd.in/eqcb7MpP

11/ Service Discovery:

↳

https://lnkd.in/eCYYwQfU

10/ Chaos Engineering:

↳

https://lnkd.in/egT6feTR

9/ Consistent Hashing:

↳

https://lnkd.in/eUP9DbCg

8/ RSocket:

↳

https://lnkd.in/ehR8td6B

7/ Monolith vs Microservices:

↳

https://lnkd.in/e3EBtg_v

6/ Saga Design Pattern:

↳

https://lnkd.in/eFXC4-aJ

5/ Capacity Planning:

↳

https://lnkd.in/ev358pj3

4/ Caching Patterns:

↳

https://lnkd.in/gJ8kWMxZ

3/ What Happens When You Type a URL Into Your Browser?:

↳

https://lnkd.in/eusuDn5z

2/ Consistency Patterns:

↳

https://lnkd.in/eFcxHisf

1/ Redis Use Cases:

↳

https://lnkd.in/ekJMjMG3



Here are some of the most commonly asked system design questions in technical interviews:

1. **Design a URL shortening service (e.g., [Bit.ly](http://bit.ly/))**
    - Consider scalability, data storage, hash collisions, and API design.
2. **Design a distributed cache**
    - How to handle eviction policies, data consistency, and fault tolerance in a distributed environment.
3. **Design a messaging system (e.g., WhatsApp, SMS)**
    - Think about message delivery guarantees (e.g., at-least-once, exactly-once), scaling to millions of users, and real-time communication.
4. **Design a social media feed (e.g., Facebook, Instagram)**
    - How to handle large-scale data, newsfeed personalization, and ranking algorithms.
5. **Design an e-commerce system**
    - Focus on catalog management, payment processing, inventory management, and high availability.
6. **Design a file storage system (e.g., Dropbox)**
    - Consider data replication, file syncing across devices, versioning, and fault tolerance.
7. **Design a ride-sharing system (e.g., Uber, Lyft)**
    - Think about user matching, route optimization, surge pricing, and geospatial indexing.
8. **Design a real-time analytics system**
    - How to process large volumes of data in real-time, using technologies like stream processing, and handle data consistency.
9. **Design a search engine**
    - Focus on indexing, ranking algorithms, handling large-scale queries, and distributed search.
10. **Design a recommendation system**
- Think about collaborative filtering, content-based filtering, and handling scalability with millions of users.
1. **Design a chat application**
- Consider handling real-time message delivery, storing chat history, and scaling to millions of users.
1. **Design a news aggregation platform**
- How to handle millions of articles, user personalization, and push notifications.
1. **Design a payment processing system**
- Address transaction reliability, security, handling concurrency, and integrating with third-party payment services.
1. **Design a notification system**
- Think about push notifications, message queuing, and user targeting based on preferences.
1. **Design a video streaming service (e.g., Netflix, YouTube)**
- Consider adaptive bitrate streaming, content delivery networks (CDNs), and scalability.

For each question, you should discuss key components like **data storage**, **scalability**, **fault tolerance**, **caching**, **load balancing**, **API design**, and **security**. It's essential to walk through trade-offs in different architectures and approaches.